# 現時点でのまとめ

第五章で扱った非正規化や、第二章で扱ったディスクI/Oの分散(RAID)以外にもパフォーマンスを向上させる施策(**パフォーマンス設計**)はある。

それは『**インデックス**』と『**統計情報**』である。

---

**インデックス**とは書籍における**索引**(各種単語とそれ等が載っているページ番号からなるもの)のようなものであり、

『**求めたいデータとそのデータがあるメモリアドレス**』といった『**キー(求めたいデータ)と値(ポインタ)**』から成る**map構造をしたオブジェクト**である。

このオブジェクトは『**DBMS内にテーブルとは独立して保持される**』といった特徴がある。

---

**統計情報**とは**求めたいデータに到達するための最短の経路情報**をはじきだす地図情報のことであり、ちょうどドライバーに対する**カーナビ**のようなものである。

以前はエンジニアがある程度この部分をコントロールすることが多かった(**ルールベース**)が、今はDBMSに一任するアーキテクチャ(**コストベース**)が主流である。

---

インデックスには、

- アプリケーションのコードに影響を与えない(**アプリケーション透過的**)

- テーブルにもそこにあるデータにも影響を与えない(**データ透過的**)

- それでいて性能改善の効果が大きい(**インデックスの性能は、データ量に対して線形よりも緩くしか劣化しない**)

上記のような基本要素がある。

インデックスにも色々な種類があるが、よく使われるのが『**B-treeインデックス**』であり、あるカラムにインデックスを貼る際は通常DBMSはこのインデックスを貼る。

B-treeインデックスは欲しいデータに対する**木構造**になっていて、**ルートノードからリーフノード、リーフノードが持つポインタが指し示すデータ、といった構造**をしている。

インデックスが貼られたカラムは**ソート化**されるので、DBMS内部でソート化される処理(**集計関数**、**集合関数**、**OLAP関数**、**group by**、**order by**等)を高速化させることができる。

- 集計関数...count, sum, avg, max, min

- 集合関数...union, intersect, except

- OLAP関数...rank, row_numberなど

上記のような特徴を持つB-treeインデックスにおいては、以下のようなテーブルのカラムにインデックスを貼ることが有効である。

- **レコード数が1万を超える**テーブルのカラム

- **カーディナリティ**(この場合のカーディナリティとは、**あるカラムにあるデータが多様である様**)が高いカラム

*ただし、そのデータが平均的に分散していて、ある特定のデータに偏って登録されていないこと*を条件とする

- **WHERE句の選択条件、結合条件**に使用されているカラム

**選択条件**、**結合条件**については以下の記事を参照。
https://blogs.itmedia.co.jp/doc-consul/2015/11/sql.html